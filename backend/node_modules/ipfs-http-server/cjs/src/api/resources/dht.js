'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var joi = require('../../utils/joi.js');
var Boom = require('@hapi/boom');
var itPipe = require('it-pipe');
var map = require('it-map');
var streamResponse = require('../../utils/stream-response.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var Boom__default = /*#__PURE__*/_interopDefaultLegacy(Boom);
var map__default = /*#__PURE__*/_interopDefaultLegacy(map);

const findPeerResource = {
  options: {
    validate: {
      options: {
        allowUnknown: true,
        stripUnknown: true
      },
      query: joi.object().keys({
        peerId: joi.string().required(),
        timeout: joi.timeout()
      }).rename('arg', 'peerId', {
        override: true,
        ignoreUndefined: true
      })
    }
  },
  async handler(request, h) {
    const {
      app: {signal},
      server: {
        app: {ipfs}
      },
      query: {peerId, timeout}
    } = request;
    let res;
    try {
      res = await ipfs.dht.findPeer(peerId, {
        signal,
        timeout
      });
    } catch (err) {
      if (err.code === 'ERR_LOOKUP_FAILED') {
        throw Boom__default['default'].notFound(err.toString());
      } else {
        throw Boom__default['default'].boomify(err, { message: err.toString() });
      }
    }
    return h.response({
      Responses: [{
          ID: res.id.toString(),
          Addrs: (res.addrs || []).map(a => a.toString())
        }],
      Type: 2
    });
  }
};
const findProvsResource = {
  options: {
    validate: {
      options: {
        allowUnknown: true,
        stripUnknown: true
      },
      query: joi.object().keys({
        cid: joi.cid().required(),
        numProviders: joi.number().integer().default(20),
        timeout: joi.timeout()
      }).rename('arg', 'cid', {
        override: true,
        ignoreUndefined: true
      }).rename('num-providers', 'numProviders', {
        override: true,
        ignoreUndefined: true
      })
    }
  },
  handler(request, h) {
    const {
      app: {signal},
      server: {
        app: {ipfs}
      },
      query: {cid, numProviders, timeout}
    } = request;
    return streamResponse.streamResponse(request, h, () => {
      return itPipe.pipe(ipfs.dht.findProvs(cid, {
        numProviders,
        signal,
        timeout
      }), async function* (source) {
        yield* map__default['default'](source, ({id, addrs}) => {
          return {
            Responses: [{
                ID: id.toString(),
                Addrs: (addrs || []).map(a => a.toString())
              }],
            Type: 4
          };
        });
      });
    });
  }
};
const getResource = {
  options: {
    validate: {
      options: {
        allowUnknown: true,
        stripUnknown: true
      },
      query: joi.object().keys({
        buffer: joi.binary().required(),
        timeout: joi.timeout()
      }).rename('arg', 'buffer', {
        override: true,
        ignoreUndefined: true
      })
    }
  },
  async handler(request, h) {
    const {
      app: {signal},
      server: {
        app: {ipfs}
      },
      query: {buffer, timeout}
    } = request;
    const res = await ipfs.dht.get(buffer, {
      signal,
      timeout
    });
    return h.response({
      Extra: res.toString(),
      Type: 5
    });
  }
};
const provideResource = {
  options: {
    validate: {
      options: {
        allowUnknown: true,
        stripUnknown: true
      },
      query: joi.object().keys({
        cid: joi.cid().required(),
        timeout: joi.timeout()
      }).rename('arg', 'cid', {
        override: true,
        ignoreUndefined: true
      })
    }
  },
  async handler(request, h) {
    const {
      app: {signal},
      server: {
        app: {ipfs}
      },
      query: {cid, timeout}
    } = request;
    await ipfs.dht.provide(cid, {
      signal,
      timeout
    });
    return h.response();
  }
};
const putResource = {
  options: {
    validate: {
      options: {
        allowUnknown: true,
        stripUnknown: true
      },
      query: joi.object().keys({
        arg: joi.array().length(2).items(joi.binary()).required(),
        timeout: joi.timeout()
      })
    }
  },
  async handler(request, h) {
    const {
      app: {signal},
      server: {
        app: {ipfs}
      },
      query: {
        arg: [key, value],
        timeout
      }
    } = request;
    await ipfs.dht.put(key, value, {
      signal,
      timeout
    });
    return h.response();
  }
};
const queryResource = {
  options: {
    validate: {
      options: {
        allowUnknown: true,
        stripUnknown: true
      },
      query: joi.object().keys({
        peerId: joi.string().required(),
        timeout: joi.timeout()
      }).rename('arg', 'peerId', {
        override: true,
        ignoreUndefined: true
      })
    }
  },
  handler(request, h) {
    const {
      app: {signal},
      server: {
        app: {ipfs}
      },
      query: {peerId, timeout}
    } = request;
    return streamResponse.streamResponse(request, h, () => {
      return itPipe.pipe(ipfs.dht.query(peerId, {
        signal,
        timeout
      }), async function* (source) {
        yield* map__default['default'](source, ({id}) => ({ ID: id.toString() }));
      });
    });
  }
};

exports.findPeerResource = findPeerResource;
exports.findProvsResource = findProvsResource;
exports.getResource = getResource;
exports.provideResource = provideResource;
exports.putResource = putResource;
exports.queryResource = queryResource;
