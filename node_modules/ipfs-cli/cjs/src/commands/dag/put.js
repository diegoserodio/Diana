'use strict';

var dagCBOR = require('@ipld/dag-cbor');
var dagPB = require('@ipld/dag-pb');
var concat = require('it-concat');
var cid = require('multiformats/cid');
var parseDuration = require('parse-duration');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () {
            return e[k];
          }
        });
      }
    });
  }
  n['default'] = e;
  return Object.freeze(n);
}

var dagCBOR__namespace = /*#__PURE__*/_interopNamespace(dagCBOR);
var dagPB__namespace = /*#__PURE__*/_interopNamespace(dagPB);
var concat__default = /*#__PURE__*/_interopDefaultLegacy(concat);
var parseDuration__default = /*#__PURE__*/_interopDefaultLegacy(parseDuration);

const inputDecoders = {
  json: buf => JSON.parse(buf.toString()),
  cbor: buf => dagCBOR__namespace.decode(buf),
  protobuf: buf => dagPB__namespace.decode(buf),
  raw: buf => buf
};
const formats = {
  cbor: 'dag-cbor',
  raw: 'raw',
  protobuf: 'dag-pb',
  'dag-cbor': 'dag-cbor',
  'dag-pb': 'dag-pb'
};
var dagPut = {
  command: 'put [data]',
  describe: 'accepts input from a file or stdin and parses it into an object of the specified format',
  builder: {
    data: { type: 'string' },
    format: {
      type: 'string',
      alias: 'f',
      default: 'cbor',
      describe: 'Format that the object will be added as',
      choices: [
        'dag-cbor',
        'dag-pb',
        'raw',
        'cbor',
        'protobuf'
      ]
    },
    'input-encoding': {
      type: 'string',
      alias: 'input-enc',
      default: 'json',
      describe: 'Format that the input object will be',
      choices: [
        'json',
        'cbor',
        'raw',
        'protobuf'
      ]
    },
    pin: {
      type: 'boolean',
      default: true,
      describe: 'Pin this object when adding'
    },
    'hash-alg': {
      type: 'string',
      alias: 'hash',
      default: 'sha2-256',
      describe: 'Hash function to use'
    },
    'cid-version': {
      type: 'integer',
      describe: 'CID version. Defaults to 0 unless an option that depends on CIDv1 is passed',
      default: 0
    },
    'cid-base': {
      describe: 'Number base to display CIDs in.',
      type: 'string',
      default: 'base58btc'
    },
    preload: {
      type: 'boolean',
      default: true,
      describe: 'Preload this object when adding'
    },
    'only-hash': {
      type: 'boolean',
      default: false,
      describe: 'Only hash the content, do not write to the underlying block store'
    },
    timeout: {
      type: 'string',
      coerce: parseDuration__default['default']
    }
  },
  async handler({
    ctx: {ipfs, print, getStdin},
    data,
    format,
    inputEncoding,
    pin,
    hashAlg,
    cidVersion,
    cidBase,
    preload,
    onlyHash,
    timeout
  }) {
    if (inputEncoding === 'cbor') {
      format = 'dag-cbor';
    } else if (inputEncoding === 'protobuf') {
      format = 'dag-pb';
    }
    format = formats[format];
    if (format !== 'dag-pb') {
      cidVersion = 1;
    }
    let source;
    if (!data) {
      source = (await concat__default['default'](getStdin(), { type: 'buffer' })).slice();
    } else {
      source = Buffer.from(data);
    }
    source = inputDecoders[inputEncoding](source);
    if (inputEncoding === 'json' && format === 'dag-cbor') {
      source = objectSlashToCID(source);
    }
    const cid = await ipfs.dag.put(source, {
      format,
      hashAlg,
      version: cidVersion,
      onlyHash,
      preload,
      pin,
      timeout
    });
    const base = await ipfs.bases.getBase(cidBase);
    print(cid.toString(base.encoder));
  }
};
function objectSlashToCID(obj) {
  if (Array.isArray(obj)) {
    return obj.map(objectSlashToCID);
  }
  if (obj && typeof obj === 'object') {
    const keys = Object.keys(obj);
    if (keys.length === 1 && '/' in obj) {
      if (typeof obj['/'] !== 'string') {
        throw new Error('link should have been a string');
      }
      return cid.CID.parse(obj['/']);
    }
    return keys.reduce((obj, key) => {
      obj[key] = objectSlashToCID(obj[key]);
      return obj;
    }, obj);
  }
  return obj;
}

module.exports = dagPut;
